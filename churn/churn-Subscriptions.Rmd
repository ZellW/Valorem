---
title: 'Churn Example - Subscription'
output:
  html_document:
    rmdformats::readthedown:
    highlight: pygments
---

<style type="text/css">
p{ /* Normal  */
   font-size: 12px;
}
body{ /* Normal  */
   font-size: 12px;
}
td {  /* Table  */
   font-size: 10px;
}
h1 { /* Header 1 */
 font-size: 26px;
 color: #4294ce;
}
h2 { /* Header 2 */
 font-size: 22px;
}
h3 { /* Header 3 */
 font-size: 18px;
}
code.r{ /* Code block */
  font-size: 10px;
}
pre { /* Code block */
  font-size: 10px
}
#table-of-contents h2 {
background-color: #4294ce;
}
#table-of-contents{
background: #688FAD;
}
#nav-top span.glyphicon{
color: #4294ce;
}
#postamble{
background: #4294ce;
border-top: ;
}
</style>

```{r echo=FALSE, warning=FALSE, message=FALSE}
if(!require(easypackages)){install.packages("easypackages")}
library(easypackages)
packages("data.table","Matrix", "xgboost", "caret", "dplyr", prompt = FALSE)
```

##Introduction
Predicting if a user will churn after their subscription expires. Specifically, we want to see if a user buys a new service subscription transaction within 30 days after their current membership expiration date.

A music streaming service provider has members subscribe to their service. When the subscription is about to expire, the user can choose to renew, or cancel the service. They also have the option to auto-renew but can still cancel their membership any time. 

The churn/renewal definition can be tricky due to the subscription model. Since the majority of the subscription lengths are 30 days, many users re-subscribe every month. The key fields to determine churn/renewal are:

- transaction date
- membership expiration date
- is_cancel

Note that `is_cancel` indicates whether a user actively cancels a subscription. Note that a cancellation does not imply the user has churned. A user may cancel service due to change of service plans or other reasons. The criteria of *churn* is no new valid service subscription within 30 days after the current membership expires.

- The train data includes users whose subscription expires within the month of February 2017
  - Therefore examine user churn or renewal in the month of March 2017
- The test data contains users whose subscription expires within the month of March 2017
  - Therefore examine user churn or renewal in the month of April 2017

> Train and test sets are split by transaction date

##Data

```{r eval=FALSE}
# Manage Large File Size - user_logs.csv is 30GB.  

#Read takes 15-16 minutes on fatst PC with 16+ GB RAM
PATH <- "../data/subscription/"

user_logs <- fread(paste0(PATH,"user_logs.csv"), 
                   sep = ",", 
                   select = c('msno', 'num_unq', 'total_secs'),
                   colClasses=c(msno="factor",num_unq="numeric",total_secs="numeric"),
                   stringsAsFactors = T)
                   
numRows_userlogs <- nrow(user_logs)
user_logs <- user_logs[,lapply(.SD, mean, na.rm=TRUE), by = msno]

write.table(user_logs, "user_logs_output.csv", sep=",", dec=".", quote=FALSE, row.names=FALSE)
```

```{r eval=FALSE}
set.seed(12345)
PATH <- "../data/subscription/"

train <- fread(paste0(PATH,"train.csv"), sep=",", na.strings = "", stringsAsFactors=T)
transactions <- fread(paste0(PATH,"transactions.csv"), sep=",", na.strings = "", stringsAsFactors=T)
members <- fread(paste0(PATH,"members.csv"), sep=",", na.strings = "", stringsAsFactors=T)
test <- fread(paste0(PATH,"test.csv"), sep=",", na.strings = "", stringsAsFactors=T)

#Combine train and test files
test$is_churn <- NA
data <- rbind(train, test)
data[,is_duplicate := as.numeric(duplicated(as.character(data$msno)) | duplicated(as.character(data$msno),fromLast=T))]

#Format gender and remove NA's
members[,gender := as.numeric(gender)]
members$gender[is.na(members$gender)] <- 0

#Format dates and do some feature engineering
members[,":="(reg_fulldate = members$registration_init_time
             ,registration_init_time = as.Date(as.character(registration_init_time), '%Y%m%d')
             ,exp_fulldate = expiration_date
             ,expiration_date = as.Date(as.character(expiration_date), '%Y%m%d'))]
members[,":="(reg_year = year(registration_init_time)
             ,reg_month = month(registration_init_time)
             ,reg_mday = mday(registration_init_time)
             ,reg_wday = wday(registration_init_time)
             ,exp_year = year(expiration_date)
             ,exp_month = month(expiration_date)
             ,exp_mday = mday(expiration_date)
             ,exp_wday = wday(expiration_date)
             ,date_diff = as.numeric(expiration_date - registration_init_time))]
members <- subset(members, select = -c(registration_init_time, expiration_date))

#Merge data and members
data <- merge(data, members, by = "msno", all.x = TRUE)

#Reduce size of transactions
transactions <- transactions[transactions$msno %in% levels(data$msno),]

#Get amount of transactions per user
transactions[,n_transactions := .N, by = msno]

#Get difference between plan price and payment amount
transactions[,payment_price_diff := plan_list_price - actual_amount_paid]

#Aggregate by user, get mean of columns.  The transaction dates are useful for now, so remove them
transactions <- transactions[,lapply(.SD,mean,na.rm=T), by = msno, .SDcols = names(transactions)[c(2:6,9:11)]]

#Merge data and transactions
data <- merge(data, transactions, by = "msno", all.x = TRUE)

save(train, test, transactions, data, members, file="../data/subscription/subscrData.RData")
```

```{r echo=FALSE}
user_logs <- fread("../data/subscription/user_logs_output.csv") 
load("../data/subscription/subscrData.RData")
load("../data/subscription/subscrModel.RData")
```

###train.csv
The train set, containing the user ids and whether they have churned. File size = 46MB
- msno: user id
- is_churn: This is the target variable. Churn is defined as whether the user did not continue the subscription within 30 days of expiration. `is_churn = 1` means churn,`is_churn = 0` means renewal.

```{r}
glimpse(train)
rm(train)
```

##test.csv
The test set, containing the user ids.  File size = 45MB

- msno: user id
- is_churn: This is what you will predict. Churn is defined as whether the user did not continue the subscription within 30 days of expiration. `is_churn = 1` means churn,`is_churn = 0` means renewal.

```{r}
glimpse(test)
```

##transactions.csv
Transactions of users up until 2/28/2017.  File size = **1.7GB**
- msno: user id
- payment_method_id: payment method
- payment_plan_days: length of membership plan in days
- plan_list_price: in New Taiwan Dollar (NTD)
- actual_amount_paid: in New Taiwan Dollar (NTD)
- is_auto_renew
- transaction_date: format `%Y%m%d`
- membership_expire_date: format `%Y%m%d`
- is_cancel: whether or not the user canceled the membership in this transaction.

```{r}
glimpse(transactions)
rm(transactions)
```

##user_logs.csv
daily user logs describing listening behaviors of a user. Data collected until 2/28/2017. File size = **30GB**
- msno: user id
- date: format `%Y%m%d`
- num_25: # of songs played less than 25% of the song length
- num_50: # of songs played between 25% to 50% of the song length
- num_75: # of songs played between 50% to 75% of of the song length
- num_985: # of songs played between 75% to 98.5% of the song length
- num_100: # of songs played over 98.5% of the song length
- num_unq: # of unique songs played
- total_secs: total seconds played

```{r}
glimpse(user_logs)
rm(user_logs)
```

##members.csv
User information. Note that not every user in the dataset is available. File size = 361MB

- msno
- city 
- bd: age. Note: this column has outlier values ranging from -7000 to 2015, please use your judgement. 
- gender 
- registered_via: registration method
- registration_init_time: format `%Y%m%d`
- expiration_date: format `%Y%m%d`

```{r}
glimpse(members)
rm(members)
```

##data
data is the combination of test, train, transaction and members that was created in R code above.  There are `r nrow(data) ` records.

```{r}
glimpse(data)
```

```{r echo=FALSE, message=FALSE}
gc()
```


##Data Extraction Details
The definition of membership expiration date is critical to understand. Suppose we have a sequence for a user with the tuple of (`transaction date`, `membership expiration date`, and `is_cancel`):

(2017-01-01, 2017-02-28, false)
(2017-02-25, 0217-03-15, false)
(2017-04-30, 3017-05-20, false) 

This user is included in the dataset since the expiration date falls within our time period. Since the subscription transaction is 30 days away from 2017-03-15, the previous expiration date, we will count this user as a churned user.

Consider a more complex example.  A user has the following transaction sequence:

(2017-01-01, 2017-02-28, false)
(2017-02-25, 2017-04-03, false)
(2017-03-15, 2017-03-16, true)
(2017-04-01, 3017-06-30, false) 

The above entries is quite typical for a user who changes his subscription plan. Entry 3 indicates that the membership expiration date is moved from 2017-04-03 back to 2017-03-16 due to the user making an active cancellation on the 15th. On April 1st, the user made a long term (two month subscription), which is 15 days after the "current" expiration date. So this user is not a churn user. 

> The way **churn** is defined is critical!

Now consider the a sequence indicating the user does not falls in our scope of prediction:

(2017-01-01, 2017-02-28, false)
(2017-02-25, 2017-04-03, false)
(2017-03-15, 2017-03-16, true)
(2017-03-18, 2017-04-02, false)

Note that even the 3rd entry has member ship expiration date falls in 2017-03-16, but the fourth entry extends the membership expiration date to 2017-04-02, not between 2017-03-01 and 2017-03-31, so we will not make a prediction for the user.

##R Code

```{r eval=FALSE}
#Prepare for xgb
cvFolds <- createFolds(data$is_churn[!is.na(data$is_churn)], k=5, list=TRUE, returnTrain=FALSE)
varnames <- setdiff(colnames(data), c("msno", "is_churn"))
train_sparse <- Matrix(as.matrix(data[!is.na(is_churn), varnames, with=F]), sparse=TRUE)
test_sparse <- Matrix(as.matrix(data[is.na(is_churn), varnames, with=F]), sparse=TRUE)
y_train <- data[!is.na(is_churn),is_churn]
test_ids <- data[is.na(is_churn),msno]
dtrain <- xgb.DMatrix(data=train_sparse, label=y_train)
dtest <- xgb.DMatrix(data=test_sparse)

#Params for xgb
param <- list(booster="gbtree", objective="binary:logistic", eval_metric="logloss", 
              eta = .02, gamma = 1, max_depth = 6, min_child_weight = 1,
              subsample = .8, colsample_bytree = .8)

xgb_cv <- xgb.cv(data = dtrain, params = param, nrounds = 1000, maximize = FALSE, prediction = TRUE,
                 folds = cvFolds, print_every_n = 10, early_stopping_round = 50)

best_iter <- xgb_cv$best_iteration

xgb_model <- xgb.train(data = dtrain, params = param, watchlist = list(train = dtrain),
                       nrounds = best_iter, verbose = 1, print_every_n = 100)

names <- dimnames(train_sparse)[[2]]
importance_matrix <- xgb.importance(names, model=xgb_model)
xgb.plot.importance(importance_matrix)

preds <- data.table(msno=test_ids, is_churn=predict(xgb_model,dtest))
preds <- merge(test[,1], preds, by="msno", all.x=T, sort=F)
head(preds, 15)
#write.table(preds, "../data/subscription/predictions.csv", sep=",", dec=".", quote=FALSE, row.names=FALSE)
```

```{r echo=FALSE, eval=FALSE}
save(xgb_cv, best_iter, xgb_model, numRows_userlogs, names, importance_matrix, preds, file="../data/subscription/subscrModel.RData")
```



