---

title: 'Churn - Subscription'
output:
  html_document:
    highlight: pygments
    theme: spacelab
    toc: yes
  pdf_document:
    toc: yes
    toc_depth: 3
header-includes: \usepackage{graphicx} \usepackage{mathtools}
---

<style type="text/css">
p{ /* Normal  */
   font-size: 12px;
}
body{ /* Normal  */
   font-size: 12px;
}
td {  /* Table  */
   font-size: 10px;
}
h1 { /* Header 1 */
 font-size: 26px;
 color: #4294ce;
}
h2 { /* Header 2 */
 font-size: 22px;
}
h3 { /* Header 3 */
 font-size: 18px;
}
code.r{ /* Code block */
  font-size: 10px;
}
pre { /* Code block */
  font-size: 10px
}
#table-of-contents h2 {
background-color: #4294ce;
}
#table-of-contents{
background: #688FAD;
}
#nav-top span.glyphicon{
color: #4294ce;
}
#postamble{
background: #4294ce;
border-top: ;
}
</style>

```{r echo=FALSE, warning=FALSE, message=FALSE}
if(!require(easypackages)){install.packages("easypackages")}
library(easypackages)
packages("data.table","Matrix", "xgboost", "caret", "dplyr", prompt = FALSE)
```

##Introduction
Predicting if a user will churn after their subscription expires. Specifically, we want to see if a user make a new service subscription transaction within 30 days after their current membership expiration date.

A music streaming service provider has members subscribe to their service. When the subscription is about to expire, the user can choose to renew, or cancel the service. They also have the option to auto-renew but can still cancel their membership any time. 

The churn/renewal definition can be tricky due to the subscription model. Since the majority of the subscription lengtha are 30 days, many users re-subscribe every month. The key fields to determine churn/renewal are:

- transaction date
- membership expiration date
- is_cancel

Note that `is_cancel` indicates whether a user actively cancels a subscription. Note that a cancellation does not imply the user has churned. A user may cancel service subscription due to change of service plans or other reasons. The criteria of *churn* is no new valid service subscription within 30 days after the current membership expires.

The train and the test data are selected from users whose membership expire within a certain month. The train data includes users whose subscription expire within the month of February 2017.  The test data contains users whose subscription expires within the month of March 2017. This means we are examining user churn or renewal roughly in the month of March 2017 for train set, and the user churn or renewal roughly in the month of April 2017. Train and test sets are split by transaction date. 

The data includes more users behaviors than the ones in train and test datasets, in order to enable participants to explore different user behaviors outside of the train and test sets. For example, a user could actively cancel the subscription, but renew within 30 days.

##Data
###train.csv
The train set, containing the user ids and whether they have churned. File size = 46MB
- msno: user id
- is_churn: This is the target variable. Churn is defined as whether the user did not continue the subscription within 30 days of expiration. `is_churn = 1` means churn,`is_churn = 0` means renewal.

##sample_submission_zero.csv
The test set, containing the user ids, in the format that we expect you to submit.  File size = 45MB

- msno: user id
- is_churn: This is what you will predict. Churn is defined as whether the user did not continue the subscription within 30 days of expiration. `is_churn = 1` means churn,`is_churn = 0` means renewal.

##transactions.csv
Transactions of users up until 2/28/2017.  File size = **1.7GB**
- msno: user id
- payment_method_id: payment method
- payment_plan_days: length of membership plan in days
- plan_list_price: in New Taiwan Dollar (NTD)
- actual_amount_paid: in New Taiwan Dollar (NTD)
- is_auto_renew
- transaction_date: format `%Y%m%d`
- membership_expire_date: format `%Y%m%d`
- is_cancel: whether or not the user canceled the membership in this transaction.

##user_logs.csv
- daily user logs describing listening behaviors of a user. Data collected until 2/28/2017. File size = **30GB**
- msno: user id
- date: format `%Y%m%d`
- num_25: # of songs played less than 25% of the song length
- num_50: # of songs played between 25% to 50% of the song length
- num_75: # of songs played between 50% to 75% of of the song length
- num_985: # of songs played between 75% to 98.5% of the song length
- num_100: # of songs played over 98.5% of the song length
- num_unq: # of unique songs played
- total_secs: total seconds played

##members.csv
User information. Note that not every user in the dataset is available. File size = 361MB

- msno
- city 
- bd: age. Note: this column has outlier values ranging from -7000 to 2015, please use your judgement. 
- gender 
- registered_via: registration method
- registration_init_time: format `%Y%m%d`
- expiration_date: format `%Y%m%d`

##Data Extraction Details
The definition of membership expiration date is critical to understnad. Suppose we have a sequence for a user with the tuple of (`transaction date`, `membership expiration date`, and `is_cancel`):

(2017-01-01, 2017-02-28, false)
(2017-02-25, 0217-03-15, false)
(2017-04-30, 3017-05-20, false) 

This user is included in the dataset since the expiration date falls within our time period. Since the subscription transaction is 30 days away from 2017-03-15, the previous expiration date, we will count this user as a churned user.

Consider a more complex example.  A user has the following transaction sequence:

(2017-01-01, 2017-02-28, false)
(2017-02-25, 2017-04-03, false)
(2017-03-15, 2017-03-16, true)
(2017-04-01, 3017-06-30, false) 

The above entries is quite typical for a user who changes his subscription plan. Entry 3 indicates that the membership expiration date is moved from 2017-04-03 back to 2017-03-16 due to the user making an active cancellation on the 15th. On April 1st, the user made a long term (two month subscription), which is 15 days after the "current" expiration date. So this user is not a churn user. 

> The way **churn** is defined is critical!

Now consider the a sequence indicating the user does not falls in our scope of prediction:

(2017-01-01, 2017-02-28, false)
(2017-02-25, 2017-04-03, false)
(2017-03-15, 2017-03-16, true)
(2017-03-18, 2017-04-02, false)

Note that even the 3rd entry has member ship expiration date falls in 2017-03-16, but the fourth entry extends the membership expiration date to 2017-04-02, not between 2017-03-01 and 2017-03-31, so we will not make a prediction for the user.

##R Code

```{r}
cat("Init")
set.seed(12345)
PATH <- "../input/"

cat("Load data")
train <- fread(paste0(PATH,"train.csv"), sep=",", na.strings = "", stringsAsFactors=T)
transactions <- fread(paste0(PATH,"transactions.csv"), sep=",", na.strings = "", stringsAsFactors=T)
members <- fread(paste0(PATH,"members.csv"), sep=",", na.strings = "", stringsAsFactors=T)
sample_submission_zero <- fread(paste0(PATH,"sample_submission_zero.csv"), sep=",", na.strings = "", stringsAsFactors=T)

cat("Combine train and test files")
sample_submission_zero$is_churn <- NA
data <- rbind(train, sample_submission_zero)
data[,is_duplicate := as.numeric(duplicated(as.character(data$msno)) | duplicated(as.character(data$msno),fromLast=T))]
rm(train);gc()

cat("Format gender and remove NA's")
members[,gender := as.numeric(gender)]
members$gender[is.na(members$gender)] <- 0

cat("Format dates and do some feature engineering")
members[,":="(reg_fulldate = members$registration_init_time
             ,registration_init_time = as.Date(as.character(registration_init_time), '%Y%m%d')
             ,exp_fulldate = expiration_date
             ,expiration_date = as.Date(as.character(expiration_date), '%Y%m%d'))]
members[,":="(reg_year = year(registration_init_time)
             ,reg_month = month(registration_init_time)
             ,reg_mday = mday(registration_init_time)
             ,reg_wday = wday(registration_init_time)
             ,exp_year = year(expiration_date)
             ,exp_month = month(expiration_date)
             ,exp_mday = mday(expiration_date)
             ,exp_wday = wday(expiration_date)
             ,date_diff = as.numeric(expiration_date - registration_init_time))]
members <- subset(members, select = -c(registration_init_time, expiration_date))

cat("Merge data and members")
data <- merge(data, members, by = "msno", all.x = TRUE)
rm(members);gc()

cat("Reduce size of transactions a bit")
transactions <- transactions[transactions$msno %in% levels(data$msno),]

cat("Get amount of transactions per user")
transactions[,n_transactions := .N, by = msno]

cat("Get difference between plan price and payment amount")
transactions[,payment_price_diff := plan_list_price - actual_amount_paid]

cat("Aggregate by user, get mean of columns")
cat("I don't think the transaction dates are useful for now, so let's remove them")
transactions <- transactions[,lapply(.SD,mean,na.rm=T), by = msno, .SDcols = names(transactions)[c(2:6,9:11)]]

cat("Merge data and transactions")
data <- merge(data, transactions, by = "msno", all.x = TRUE)
rm(transactions);gc()

cat("Prepare for xgb")
cvFolds <- createFolds(data$is_churn[!is.na(data$is_churn)], k=5, list=TRUE, returnTrain=FALSE)
varnames <- setdiff(colnames(data), c("msno", "is_churn"))
train_sparse <- Matrix(as.matrix(data[!is.na(is_churn), varnames, with=F]), sparse=TRUE)
test_sparse <- Matrix(as.matrix(data[is.na(is_churn), varnames, with=F]), sparse=TRUE)
y_train <- data[!is.na(is_churn),is_churn]
test_ids <- data[is.na(is_churn),msno]
dtrain <- xgb.DMatrix(data=train_sparse, label=y_train)
dtest <- xgb.DMatrix(data=test_sparse)

cat("Params for xgb")
param <- list(booster="gbtree",
              objective="binary:logistic",
              eval_metric="logloss",
              eta = .02,
              gamma = 1,
              max_depth = 6,
              min_child_weight = 1,
              subsample = .8,
              colsample_bytree = .8
)

cat("Xgb cross-validation, uncomment when running locally")
# xgb_cv <- xgb.cv(data = dtrain,
#                  params = param,
#                  nrounds = 1000,
#                  maximize = FALSE,
#                  prediction = TRUE,
#                  folds = cvFolds,
#                  print_every_n = 10,
#                  early_stopping_round = 50)
# best_iter <- xgb_cv$best_iteration
best_iter <- 1512

cat("xgb model")
xgb_model <- xgb.train(data = dtrain,
                       params = param,
                       watchlist = list(train = dtrain),
                       nrounds = best_iter,
                       verbose = 1,
                       print_every_n = 100
)

cat("Feature importance")
names <- dimnames(train_sparse)[[2]]
importance_matrix <- xgb.importance(names, model=xgb_model)
xgb.plot.importance(importance_matrix)

cat("Predict and output csv")
preds <- data.table(msno=test_ids, is_churn=predict(xgb_model,dtest))
preds <- merge(sample_submission_zero[,1], preds, by="msno", all.x=T, sort=F)
write.table(preds, "submission.csv", sep=",", dec=".", quote=FALSE, row.names=FALSE)
```



```{r, out.width = "300px", echo=FALSE}

knitr::include_graphics("./images/tsa1.JPG")

```

#detach("package:ggmosaic", unload=TRUE)


